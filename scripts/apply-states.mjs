// scripts/apply-states.mjs
import { existsSync, mkdirSync, writeFileSync } from "node:fs";
import { parseCsv, readText, writeCsv } from "./lib/csv.mjs";

const STATES = "db/states.csv";
const CAND = "db/state-link-candidates.csv";
const OUTSQL = "db/upsert-states.sql";

function idx(rows) {
  if (!rows.length) return { header: [], data: [], i: {} };
  const [h, ...data] = rows;
  const i = Object.fromEntries(h.map((k, n) => [k.trim().toLowerCase(), n]));
  return { header: h, data, i };
}
function booly(v) { return /^(1|y|yes|true)$/i.test(String(v || "").trim()); }
function sqlEscape(s) { return String(s ?? "").replace(/'/g, "''"); }

function loadCsv(path) {
  if (!existsSync(path)) return { header: [], data: [], i: {} };
  const rows = parseCsv(readText(path));
  return idx(rows);
}

function pickApproved(cand) {
  if (!cand.data.length) return new Map();
  const hasApproved = cand.header.some(h => /^approved$/i.test(h));
  const map = new Map();

  // group by code
  const byCode = new Map();
  for (const r of cand.data) {
    const code = r[cand.i.code];
    if (!code) continue;
    if (!byCode.has(code)) byCode.set(code, []);
    byCode.get(code).push(r);
  }

  for (const [code, rows] of byCode) {
    let row;
    if (hasApproved) {
      row = rows.find(r => booly(r[cand.i.approved]));
    }
    if (!row) row = rows[0];
    if (!row) continue;
    map.set(code, {
      code,
      url: row[cand.i.candidate_url],
      title: row[cand.i.page_title] || "",
      source: row[cand.i.source] || "",
      confidence: Number(row[cand.i.confidence] || 0)
    });
  }
  return map;
}

function writeUpsertSql(changes, statesCurrent) {
  const lines = [];
  lines.push("-- Generated by apply-states.mjs");
  lines.push("PRAGMA foreign_keys = ON;");
  for (const ch of changes) {
    const cur = statesCurrent.get(ch.code);
    const name = cur?.name || "";
    const sql = `INSERT INTO states (code,name,link,unavailable)
VALUES ('${sqlEscape(ch.code)}','${sqlEscape(name)}','${sqlEscape(ch.url)}',0)
ON CONFLICT(code) DO UPDATE SET name=excluded.name, link=excluded.link, unavailable=0;`;
    lines.push(sql);
  }
  mkdirSync("db", { recursive: true });
  writeFileSync(OUTSQL, lines.join("\n") + "\n", "utf8");
}

async function main() {
  if (!existsSync(CAND)) {
    console.log("No state candidates file found; nothing to apply.");
    return;
  }
  const cand = loadCsv(CAND);
  const states = loadCsv(STATES);

  if (!states.data.length) {
    console.error("states.csv is missing/empty.");
    process.exit(1);
  }
  if (!cand.data.length) {
    console.log("state-link-candidates.csv has 0 rows; nothing to apply.");
    return;
  }

  const approved = pickApproved(cand);
  if (approved.size === 0) {
    console.log("No approved candidates and no rows to auto-pick; nothing to apply.");
    return;
  }

  // current states map
  const statesMap = new Map(
    states.data.map(r => [
      r[states.i.code],
      { code: r[states.i.code], name: r[states.i.name], link: r[states.i.link], unavailable: r[states.i.unavailable] }
    ])
  );

  // apply to memory & collect changed
  const changes = [];
  for (const [code, pick] of approved) {
    const cur = statesMap.get(code);
    if (!cur) continue;
    if (cur.link === pick.url) continue;
    cur.link = pick.url;
    cur.unavailable = "0";
    changes.push({ code, url: pick.url });
  }

  if (!changes.length) {
    console.log("No state link changes needed.");
    return;
  }

  // write updated states.csv
  const outRows = Array.from(statesMap.values()).map(s => [s.code, s.name, s.link || "", String(s.unavailable ?? 0)]);
  writeCsv(STATES, ["code","name","link","unavailable"], outRows);
  writeUpsertSql(changes, statesMap);

  console.log(`Applied ${changes.length} state link change(s).`);
  console.log(`Updated: ${STATES}`);
  console.log(`Generated D1 SQL: ${OUTSQL}`);
  console.log("Paste db/upsert-states.sql into the Cloudflare D1 Console to update prod.");
}

main().catch(e => { console.error(e); process.exit(1); });
